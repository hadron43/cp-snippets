{
	"Competetive Programming": {
		"prefix": "_cp",
		"body": [
			"/*",
			" * @hadron43, Expert soon",
			" * Good luck!",
			" */",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define modulo 1000000007",
			"#define maxsize 200000",
			"typedef long long ll;",
			"",
			"// vector<ll> arr;",
			"// map<ll, ll> m;",
			"ll T, n, in;",
			"",
			"void solve() {",
			"\t$0",
			"}",
			"",
			"int main() {",
				"\tcin>>T;",
				"\tfor(int t=0; t<T; ++t) {",
					"\t\tcin>>n;",
					"\t\tsolve();",
				"\t}",
			"}",
			""
		],
		"description": "cp boiler code"
	},

	"Binary Exponentiation": {
		"prefix": "_binpow",
		"body": [
			"ll binpow(ll a, ll b) {",
				"\ta %= modulo;",
				"\tll res = 1;",
				"\twhile (b > 0) {",
					"\t\tif (b & 1)",
						"\t\t\tres = res * a % modulo;",
					"\t\ta = a * a % modulo;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}",
			""
		],
		"description": "Binary Exponentiation With Modulo"
	},

	"Modular Inverse": {
		"prefix": "_modinv",
		"body": [
			"ll modinv(ll a) { return binpow(a, modulo-2); }\n"
		],
		"description": "Modular Inverse Algorithm"
	},

	"Greatest Common Divisor" : {
		"prefix": "_gcd",
		"body": "ll gcd(ll a, ll b) { if (a == 0) return b; return gcd(b % a, a); }\n",
		"description": "Euclid Algorithm for returning the gcd of two integers"
	},

	"Merge Sort" : {
		"prefix": "_mergesort",
		"body":
		[
			"void merge(int arr[], int beg, int mid, int end, int maxele) {",
			"\tint i = beg, j = mid + 1, k = beg;",
			"\twhile (i <= mid && j <= end) {",
			"\t\tif (arr[i] % maxele <= arr[j] % maxele) {",
			"\t\t\tarr[k] = arr[k] + (arr[i] % maxele) * maxele;",
			"\t\t\tk++; i++;",
			"\t\t}",
			"\t\telse {",
			"\t\t\tarr[k] = arr[k] + (arr[j] % maxele) * maxele;",
			"\t\t\tk++; j++;",
			"\t\t}",
			"\t}",
			"\twhile (i <= mid) {",
			"\t\tarr[k] = arr[k] + (arr[i] % maxele) * maxele;",
			"\t\tk++; i++;",
			"\t}",
			"\twhile (j <= end) {",
			"\t\tarr[k] = arr[k] + (arr[j] % maxele) * maxele;",
			"\t\tk++; j++;",
			"\t}",
			"\t// Obtaining actual values",
			"\tfor (int i = beg; i <= end; i++)",
			"\t\tarr[i] = arr[i] / maxele;",
			"}",
			"",
			"// Recursive merge sort with extra parameter, naxele",
			"void mergeSortRec(int arr[], int beg, int end, int maxele) {",
			"\tif (beg < end) {",
			"\t\tint mid = (beg + end) / 2;",
			"\t\tmergeSortRec(arr, beg, mid, maxele);",
			"\t\tmergeSortRec(arr, mid + 1, end, maxele);",
			"\t\tmerge(arr, beg, mid, end, maxele);",
			"\t}",
			"}",
			"",
			"// This functions finds max element and calls recursive",
			"// merge sort.",
			"void mergeSort(int arr[], int n) {",
			"\tint maxele = *max_element(arr, arr+n) + 1;",
			"\tmergeSortRec(arr, 0, n-1, maxele);",
			"}",
			""
		],
		"description": "Divide and Conquer algorithm for sorting an array"
	}
}